{"version":3,"file":"web-directive.js","sources":["../src/utilities/lifecycle.ts","../src/utilities/dom.ts","../src/utilities/text.ts","../src/utilities/timing.ts","../src/index.ts"],"sourcesContent":["import WebDirective from '../index';\n\nexport function useCurrentContext() {\n  if (!WebDirective.currentContext) {\n    throw new Error('No active context found.');\n  }\n\n  return WebDirective.currentContext;\n}\n","import { useCurrentContext } from './lifecycle';\n\nexport function setData(el: Element, name: string, value: any) {\n  // @ts-ignore\n  el[name] = value;\n}\n\nexport function getDate(el: Element, name: string): any {\n  // @ts-ignore\n  return el[name];\n}\n\nconst storageKey = `__webDirective.${createUid()}`;\n\nexport function singleton<E extends Element, T = any>(el: E, name: string): T | undefined;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory: false): T | undefined;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory: (el: E) => T): T;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory?: ((el: E) => T) | false): T | undefined {\n  const element = el as any;\n\n  element[storageKey] ??= {};\n\n  if (factory === false) {\n    const instance = element[storageKey][name];\n\n    delete element[storageKey][name];\n    return instance;\n  }\n\n  if (!element[storageKey][name] && factory) {\n    element[storageKey][name] = factory(el);\n  }\n\n  return element[storageKey][name];\n}\n\nfunction createUid() {\n  return Math.random().toString(36).substring(2, 10);\n}\n\nexport function useEventListener(el: Element, event: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) {\n  const { el: baseEl, binding } = useCurrentContext();\n\n  el.addEventListener(event, handler, options);\n\n  const off = () => {\n    el.removeEventListener(event, handler, options);\n  };\n\n  baseEl.addEventListener('__wd:unmounted:' + binding.directive, (e) => {\n    off();\n  }, { once: true });\n\n  return off;\n}\n","export function toCamelCase(text: string): string {\n  return text.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function toKebabCase(text: string): string {\n  return text.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n","export function nextTick(): Promise<void> {\n  return Promise.resolve().then();\n}\n\n","import type { WebDirectiveBaseHook, WebDirectiveBinding, WebDirectiveHandler, WebDirectiveOptions } from './types';\nimport { toCamelCase, toKebabCase } from './utilities';\n\nexport { singleton, nextTick, useCurrentContext, useEventListener } from './utilities';\nexport type {\n  WebDirectiveBinding,\n  WebDirectiveHandler,\n  WebDirectiveOptions,\n} from './types';\n\nconst defaultOptions: Required<WebDirectiveOptions> = {\n  prefix: 'w-',\n  eventPrefix: 'wd:',\n  enableAttrParams: false,\n  enableChildrenUpdated: false,\n};\n\ninterface DirectiveInfo {\n  name: string;\n  handler: WebDirectiveHandler<any>;\n  elements: HTMLElement[];\n}\n\ninterface ElementInfo {\n  el: Element;\n  disconnect: () => void;\n  directives: string[];\n}\n\ntype HookTask = 'mounted' | 'unmounted' | 'updated' | 'childrenUpdated';\n\nclass WebDirective {\n  private directives: Record<string, DirectiveInfo> = {};\n\n  private attachedElements: WeakMap<Element, ElementInfo> = new WeakMap();\n\n  listenTarget: HTMLElement = document.body;\n\n  options: Required<WebDirectiveOptions>;\n\n  private disconnectCallback?: (() => void);\n\n  static currentContext: { el: Element, binding: WebDirectiveBinding } | null = null;\n\n  private hooks: {\n    mounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    unmounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    updated?: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    },\n    childrenUpdated?: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    }\n  } = {\n    mounted: {\n      before: (node, bindings) => {\n        const directive = bindings.directive;\n        const name = bindings.name;\n\n        let elementInfo = this.attachedElements.get(node);\n\n        if (!elementInfo) {\n          this.attachedElements.set(node, elementInfo = {\n            el: node,\n            disconnect: this.observeAttachedElement(node),\n            directives: [],\n          });\n        }\n\n        if (!elementInfo.directives.includes(directive)) {\n          elementInfo.directives.push(directive);\n        }\n      }\n    },\n    unmounted: {\n      after: (node, bindings) => {\n        const directive = bindings.directive;\n\n        const elementInfo = this.attachedElements.get(node);\n\n        if (elementInfo) {\n          const index = elementInfo.directives.indexOf(directive);\n\n          if (index > -1) {\n            elementInfo.directives.splice(index, 1);\n          }\n\n          if (elementInfo.directives.length === 0) {\n            elementInfo.disconnect();\n            this.attachedElements.delete(node);\n          }\n        }\n      }\n    }\n  };\n\n  constructor(options: WebDirectiveOptions = {}) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  listen(target?: HTMLElement): void {\n    if (this.disconnectCallback) {\n      throw new Error('This instance has already listening.');\n    }\n\n    this.listenTarget = target || document.body;\n\n    const disconnectRoot = this.observeRoot(this.listenTarget);\n\n    this.disconnectCallback = () => {\n      disconnectRoot();\n\n      for (const directive in this.directives) {\n        for (const element of this.directives[directive].elements) {\n          for (const directiveWithArgs of this.findDirectivesFromNode(element, directive)) {\n            this.runDirectiveIfExists(directiveWithArgs, element, 'unmounted');\n          }\n        }\n      }\n    };\n\n    // Mount registered directive before listen.\n    for (const directive in this.directives) {\n      this.findAndRunDirectivesOfSubtree(this.listenTarget, 'mounted', undefined, directive);\n    }\n  }\n\n  register<T extends Element = HTMLElement, M extends Record<string, boolean> = Record<string, boolean>>(\n    name: string,\n    handler: WebDirectiveHandler<T, M>\n  ) {\n    const directive = this.getDirectiveAttrName(name);\n    this.directives[directive] = {\n      name: directive,\n      handler: handler as WebDirectiveHandler<T, Record<string, boolean>>,\n      elements: []\n    };\n\n    // If listen not start, just register and back\n    if (!this.disconnectCallback) {\n      return;\n    }\n\n    // If listen already started, mount this directive\n    this.findAndRunDirectivesOfSubtree(this.listenTarget, 'mounted', undefined, directive);\n  }\n\n  // private mountDirectiveInitial(directive: string) {\n  //   this.findAndRunDirectivesOfSubtree(this.listenTarget, 'unmounted');\n  //\n  //   // if (this.options.enableAttrParams) {\n  //   //   for (const element of this.listenTarget.querySelectorAll<HTMLElement>('*')) {\n  //   //     this.findAndRunDirectivesFromNode(element, 'mounted', undefined, directive);\n  //   //\n  //   //     // const attributes = element.getAttributeNames();\n  //   //     //\n  //   //     // for (const attribute of attributes) {\n  //   //     //   if (attribute.startsWith(directive)) {\n  //   //     //     this.runDirectiveIfExists(attribute, element, 'mounted');\n  //   //     //   }\n  //   //     // }\n  //   //   }\n  //   //\n  //   //   return;\n  //   // }\n  //   //\n  //   // for (const element of this.listenTarget.querySelectorAll<HTMLElement>(`[${directive}]`)) {\n  //   //   this.runDirectiveIfExists(directive, element, 'mounted');\n  //   // }\n  // }\n\n  /**\n   * This method is to listen the root element for any changes.\n   * The listen event contains:\n   * - Child added/removed, and will scan all directives from added/removed nodes\n   * - Self Attributes changed\n   *\n   * This listener will run forever until disconnect() is called.\n   */\n  private observeRoot(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        // Added Nodes\n        for (const node of mutation.addedNodes) {\n          // Run self mounted\n          this.findAndRunDirectivesOfNode(node as HTMLElement, 'mounted', mutation);\n\n          // Run all subtree mounted\n          this.findAndRunDirectivesOfSubtree(node as HTMLElement, 'mounted', mutation);\n        }\n\n        // Handle if attributes remove from node\n        for (const node of mutation.removedNodes) {\n          // Run self unmounted\n          this.findAndRunDirectivesOfNode(node as HTMLElement, 'unmounted', mutation);\n\n          // Run all subtree unmounted\n          this.findAndRunDirectivesOfSubtree(node as HTMLElement, 'unmounted', mutation);\n\n          // this.findDirectivesFromNode(node).forEach((directiveWithArgs) => {\n          //   this.runDirectiveIfExists(directiveWithArgs, node as HTMLElement, 'unmounted', mutation);\n          // });\n        }\n\n        // Handle attributes value changed\n        const currentValue = (mutation.target as HTMLElement).getAttribute(mutation.attributeName!);\n\n        // If current value is NULL, it means the attribute is removed, so skip it here\n        // We will handle the removed case in the observeAttachedElement()\n        if (mutation.type === 'attributes' && currentValue != null) {\n          this.runDirectiveIfExists(\n            mutation.attributeName!,\n            mutation.target as HTMLElement,\n            mutation.oldValue == null ? 'mounted' : 'updated',\n            mutation\n          );\n        }\n      }\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      attributeOldValue: true,\n      childList: this.options.enableChildrenUpdated,\n      characterData: false,\n      subtree: true\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  /**\n   * This method is to listen an element which is attached at least 1 or more directives.\n   * The listen event contains:\n   * - Self attributes changed\n   * - Children changed (if enabled)\n   *\n   * And this listener will be removed when all directives are unmounted from this element.\n   */\n  private observeAttachedElement(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        // Attributes updated\n        if (\n          mutation.type === 'attributes'\n          && mutation.attributeName\n          && mutation.target === element\n        ) {\n          if (!(mutation.target as Element).getAttribute(mutation.attributeName!)) {\n            // Remove\n            this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'unmounted', mutation);\n          } else {\n            // Attribute value changed\n            this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'updated', mutation);\n          }\n        }\n\n        // Children changed. Let's run all attributes\n        if (this.options.enableChildrenUpdated && mutation.type === 'childList') {\n          for (const directiveWithArgs of this.findDirectivesFromNode(element)) {\n            this.runDirectiveIfExists(directiveWithArgs, element as HTMLElement, 'childrenUpdated', mutation);\n          }\n        }\n      }\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      childList: this.options.enableChildrenUpdated,\n      subtree: this.options.enableChildrenUpdated,\n      characterData: true,\n      attributeOldValue: true,\n      characterDataOldValue: true,\n      // attributeFilter: Object.keys(this.directives)\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  remove(name: string) {\n    const directive = this.getDirectiveAttrName(name);\n\n    if (this.directives[directive]) {\n      for (const element of this.directives[directive].elements) {\n        for (const directiveWithArgs of this.findDirectivesFromNode(element, directive)) {\n          this.runDirectiveIfExists(directiveWithArgs, element, 'unmounted');\n        }\n      }\n\n      delete this.directives[directive];\n    }\n  }\n\n  getPrefix() {\n    return this.options.prefix;\n  }\n\n  getDirectiveAttrName(name: string): string {\n    return `${this.getPrefix()}${name}`;\n  }\n\n  disconnect() {\n    if (this.disconnectCallback) {\n      this.disconnectCallback();\n      this.disconnectCallback = undefined;\n    }\n  }\n\n  getDirectiveInfo(directive: string): DirectiveInfo | undefined {\n    return this.directives[directive];\n  }\n\n  private splitDirectiveArgs(directive: string) {\n    const [nameWithArg, ...modifierParts] = directive.split('.');\n    const [name, arg] = nameWithArg.split(':');\n\n    const modifiers: Record<string, boolean> = {};\n    modifierParts.forEach((mod) => {\n      modifiers[toCamelCase(mod)] = true;\n    });\n\n    return { name, arg: arg || null, modifiers };\n  }\n\n  private runDirectiveIfExists(\n    directive: string,\n    el: HTMLElement,\n    task: HookTask,\n    mutation: MutationRecord | undefined = undefined\n  ) {\n    const { name, arg, modifiers } = this.splitDirectiveArgs(directive);\n\n    const info = this.getDirectiveInfo(name);\n\n    if (!info) {\n      return;\n    }\n\n    if (task === 'mounted') {\n      // Add element to directive map\n      info.elements.push(el);\n    } else if (task === 'unmounted') {\n      // Remove element from directive map\n      const index = info.elements.indexOf(el);\n\n      if (index > -1) {\n        info.elements.splice(index, 1);\n      }\n    }\n\n    const handler = info.handler;\n\n    const binding: WebDirectiveBinding = {\n      directive,\n      name,\n      node: el,\n      value: el.getAttribute(directive),\n      oldValue: mutation?.oldValue,\n      mutation,\n      handler,\n      arg,\n      modifiers,\n      instance: this,\n    };\n\n    WebDirective.currentContext = { el, binding };\n\n    if (this.hooks?.[task]?.before) {\n      this.hooks[task]?.before?.(el, binding);\n    }\n\n    if (task in handler) {\n      handler[task]?.(el, binding);\n    }\n\n    if (this.hooks?.[task]?.after) {\n      this.hooks[task]?.after?.(el, binding);\n    }\n\n    const eventPrefix = this.options.eventPrefix;\n\n    el.dispatchEvent(new CustomEvent(eventPrefix + toKebabCase(task), { detail: { el, binding }}));\n    el.dispatchEvent(new CustomEvent(`__wd:${task}:${binding.directive}`, { detail: { el, binding }}));\n\n    WebDirective.currentContext = null;\n  }\n\n  private findAndRunDirectivesOfNode(\n    node: HTMLElement,\n    task: HookTask,\n    mutation?: MutationRecord,\n    directive?: string,\n  ) {\n    for (const directiveWithArgs of this.findDirectivesFromNode(node, directive)) {\n      this.runDirectiveIfExists(directiveWithArgs, node, task, mutation);\n    }\n  }\n\n  private findAndRunDirectivesOfSubtree(node: Element, task: HookTask, mutation?: MutationRecord, directive?: string) {\n    if (!('querySelectorAll' in node)) {\n      return;\n    }\n\n    if (this.options.enableAttrParams) {\n      for (const childNode of node.querySelectorAll<HTMLElement>('*')) {\n        this.findAndRunDirectivesOfNode(childNode, task, mutation, directive);\n      }\n    } else {\n      const directives = directive ? [directive] : Object.keys(this.directives);\n\n      for (const directive of directives) {\n        for (const element of node.querySelectorAll<HTMLElement>(`[${directive}]`)) {\n          this.runDirectiveIfExists(directive, element, task);\n        }\n      }\n    }\n  }\n\n  private findDirectivesFromNode(node: Element, directive?: string): string[] {\n    const directives: string[] = [];\n\n    if (!node.getAttributeNames) {\n      return [];\n    }\n\n    node.getAttributeNames().forEach((e) => {\n      if (e.startsWith(this.getPrefix())) {\n        if (!directive) {\n          directives.push(e);\n        } else if (e.startsWith(directive)) {\n          directives.push(e);\n        }\n      }\n    });\n\n    return directives;\n  }\n}\n\nexport default WebDirective;\n"],"names":["useCurrentContext","WebDirective","storageKey","createUid","singleton","el","name","factory","element","instance","useEventListener","event","handler","options","baseEl","binding","off","e","toCamelCase","text","g","toKebabCase","nextTick","defaultOptions","_WebDirective","node","bindings","directive","elementInfo","index","target","disconnectRoot","directiveWithArgs","observer","mutations","mutation","currentValue","nameWithArg","modifierParts","arg","modifiers","mod","task","info","eventPrefix","childNode","directives"],"mappings":"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"}