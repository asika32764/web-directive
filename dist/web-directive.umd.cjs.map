{"version":3,"file":"web-directive.umd.cjs","sources":["../src/index.ts"],"sourcesContent":["import type { WebDirectiveBaseHook, WebDirectiveHandler, WebDirectiveOptions } from './types';\n\nconst disconnectKey = '_webDirectiveDisconnectors';\n\nconst defaultOptions: Required<WebDirectiveOptions> = {\n  prefix: 'w-',\n};\n\nclass WebDirective {\n  directives: Record<string, WebDirectiveHandler> = {};\n\n  instances: Record<string, any[]> = {};\n\n  listenTarget: HTMLElement = document.body;\n\n  options: Required<WebDirectiveOptions>;\n\n  disconnectCallback?: (() => void);\n\n  hooks: {\n    mounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    unmounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    updated?: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    }\n  } = {\n    mounted: {\n      before: (directive: string, node: Element) => {\n        node[disconnectKey] = node[disconnectKey] || {};\n        node[disconnectKey][directive] = this.observeChildren(node);\n\n        this.instances[directive] = this.instances[directive] || [];\n        this.instances[directive].push(node);\n      }\n    },\n    unmounted: {\n      after: (directive, node: Element) => {\n        if (!node[disconnectKey]) {\n          return;\n        }\n\n        if (node[disconnectKey][directive]) {\n          node[disconnectKey][directive]();\n          delete node[disconnectKey][directive];\n        }\n      }\n    }\n  };\n\n  constructor(options: WebDirectiveOptions = {}) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  register(name: string, handler: WebDirectiveHandler) {\n    const directive = this.getDirectiveAttrName(name);\n    this.directives[directive] = handler;\n\n    // If listen not start, just register and back\n    if (!this.disconnectCallback) {\n      return;\n    }\n\n    // If listen already started, mount this directive\n    this.mountDirectiveInitial(directive);\n  }\n\n  private mountDirectiveInitial(directive: string) {\n    const elements = Array.from(this.listenTarget.querySelectorAll<HTMLElement>('*'));\n\n    for (const element of elements) {\n      const attributes = element.getAttributeNames();\n\n      for (const attribute of attributes) {\n        console.log(attribute);\n        if (attribute.startsWith(directive)) {\n          this.runDirectiveIfExists(directive, element, 'mounted');\n        }\n      }\n    }\n  }\n\n  remove(name: string) {\n    // Todo: Handle with args\n    const directive = this.getDirectiveAttrName(name);\n\n    if (this.instances[directive]) {\n      this.instances[directive].forEach((node) => {\n        this.runDirectiveIfExists(directive, node, 'unmounted');\n      });\n\n      delete this.instances[directive];\n    }\n\n    delete this.directives[directive];\n  }\n\n  getPrefix() {\n    return this.options.prefix;\n  }\n\n  getDirectiveAttrName(name: string): string {\n    return `${this.getPrefix()}${name}`;\n  }\n\n  private observeRoot(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        // Added Nodes\n        [].forEach.call(mutation.addedNodes, (node: Node) => {\n          this.findDirectivesFromNode(node as Element).forEach((directive) => {\n            this.runDirectiveIfExists(directive, node as HTMLElement, 'mounted', mutation);\n          });\n\n          // Find children with all directives\n          for (const directive in this.directives) {\n            if ('querySelectorAll' in node) {\n              (node as HTMLElement).querySelectorAll<HTMLElement>(`[${directive}]`).forEach((node: HTMLElement) => {\n                this.runDirectiveIfExists(directive, node, 'mounted', mutation);\n              });\n            }\n          }\n        });\n\n        [].forEach.call(mutation.removedNodes, (node: Element) => {\n          this.findDirectivesFromNode(node).forEach((directive) => {\n            this.runDirectiveIfExists(directive, node as HTMLElement, 'unmounted', mutation);\n          });\n        });\n\n        if (mutation.type === 'attributes' && mutation.oldValue == null) {\n          this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'mounted', mutation);\n        }\n      });\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      attributeOldValue: true,\n      childList: true,\n      characterData: false,\n      subtree: true\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  private observeChildren(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        // Remove\n        if (mutation.type === 'attributes' && !(mutation.target as Element).getAttribute(mutation.attributeName!)) {\n          this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'unmounted', mutation);\n        }\n\n        this.findDirectivesFromNode(mutation.target as Element).forEach((directive) => {\n          // Attributes\n          if (mutation.type === 'attributes' || mutation.type === 'childList') {\n            this.runDirectiveIfExists(directive, mutation.target as HTMLElement, 'updated', mutation);\n          }\n        });\n      });\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      childList: true,\n      characterData: true,\n      attributeOldValue: true,\n      characterDataOldValue: true,\n      attributeFilter: Object.keys(this.directives)\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  listen(target?: HTMLElement): void {\n    if (this.disconnectCallback) {\n      throw new Error('This instance has already listening.');\n    }\n\n    this.listenTarget = target || document.body;\n\n    this.disconnectCallback = this.observeRoot(this.listenTarget);\n\n    // Mount registered directive before listen.\n    for (const directive in this.directives) {\n      this.mountDirectiveInitial(directive);\n    }\n  }\n\n  disconnect() {\n    if (this.disconnectCallback) {\n      this.disconnectCallback();\n      this.disconnectCallback = undefined;\n    }\n  }\n\n  getDirective(directive: string): WebDirectiveHandler {\n    return this.directives[directive];\n  }\n\n  private splitDirectiveArgs(directive: string) {\n    const [nameWithArg, ...modifierParts] = directive.split('.');\n    const [name, arg] = nameWithArg.split(':');\n\n    const modifiers: Record<string, boolean> = {};\n    modifierParts.forEach((mod) => {\n      modifiers[mod] = true;\n    });\n\n    return { name, arg: arg || null, modifiers };\n  }\n\n  private runDirectiveIfExists(\n    directive: string,\n    node: HTMLElement,\n    task: 'mounted' | 'unmounted' | 'updated',\n    mutation: MutationRecord | undefined = undefined\n  ) {\n    console.log(directive);\n    const { name, arg, modifiers } = this.splitDirectiveArgs(directive);\n    directive = name;\n\n    const handler = this.getDirective(directive);\n\n    if (handler && task in handler) {\n      if (this.hooks?.[task]?.before) {\n        this.hooks[task]?.before?.(directive, node);\n      }\n\n      handler[task]?.(node, {\n        directive,\n        node,\n        value: node.getAttribute(directive),\n        oldValue: mutation?.oldValue,\n        mutation,\n        handler,\n        arg,\n        modifiers\n      });\n\n      if (this.hooks?.[task]?.after) {\n        this.hooks[task]?.after?.(directive, node);\n      }\n    }\n  }\n\n  private findDirectivesFromNode(node: Element): string[] {\n    const directives: string[] = [];\n\n    if (!node.getAttributeNames) {\n      return [];\n    }\n\n    node.getAttributeNames().forEach((e) => {\n      if (e.startsWith(this.getPrefix())) {\n        directives.push(e);\n      }\n    });\n\n    return directives;\n  }\n}\n\nexport default WebDirective;\n"],"names":["disconnectKey","defaultOptions","WebDirective","options","directive","node","name","handler","elements","element","attributes","attribute","observer","mutations","mutation","target","nameWithArg","modifierParts","arg","modifiers","mod","task","directives"],"mappings":"8NAEA,MAAMA,EAAgB,6BAEhBC,EAAgD,CACpD,OAAQ,IACV,EAEA,MAAMC,CAAa,CAgDjB,YAAYC,EAA+B,GAAI,CA/C/C,KAAA,WAAkD,CAAA,EAElD,KAAA,UAAmC,CAAA,EAEnC,KAAA,aAA4B,SAAS,KAMrC,KAAA,MAaI,CACF,QAAS,CACP,OAAQ,CAACC,EAAmBC,IAAkB,CAC5CA,EAAKL,CAAa,EAAIK,EAAKL,CAAa,GAAK,CAAA,EAC7CK,EAAKL,CAAa,EAAEI,CAAS,EAAI,KAAK,gBAAgBC,CAAI,EAE1D,KAAK,UAAUD,CAAS,EAAI,KAAK,UAAUA,CAAS,GAAK,CAAA,EACzD,KAAK,UAAUA,CAAS,EAAE,KAAKC,CAAI,CACrC,CAAA,EAEF,UAAW,CACT,MAAO,CAACD,EAAWC,IAAkB,CAC9BA,EAAKL,CAAa,GAInBK,EAAKL,CAAa,EAAEI,CAAS,IAC/BC,EAAKL,CAAa,EAAEI,CAAS,EAAA,EAC7B,OAAOC,EAAKL,CAAa,EAAEI,CAAS,EAExC,CAAA,CACF,EAIA,KAAK,QAAU,OAAO,OAAO,CAAA,EAAIH,EAAgBE,CAAO,CAC1D,CAEA,SAASG,EAAcC,EAA8B,CACnD,MAAMH,EAAY,KAAK,qBAAqBE,CAAI,EAChD,KAAK,WAAWF,CAAS,EAAIG,EAGxB,KAAK,oBAKV,KAAK,sBAAsBH,CAAS,CACtC,CAEQ,sBAAsBA,EAAmB,CAC/C,MAAMI,EAAW,MAAM,KAAK,KAAK,aAAa,iBAA8B,GAAG,CAAC,EAEhF,UAAWC,KAAWD,EAAU,CAC9B,MAAME,EAAaD,EAAQ,kBAAA,EAE3B,UAAWE,KAAaD,EACtB,QAAQ,IAAIC,CAAS,EACjBA,EAAU,WAAWP,CAAS,GAChC,KAAK,qBAAqBA,EAAWK,EAAS,SAAS,CAG7D,CACF,CAEA,OAAOH,EAAc,CAEnB,MAAMF,EAAY,KAAK,qBAAqBE,CAAI,EAE5C,KAAK,UAAUF,CAAS,IAC1B,KAAK,UAAUA,CAAS,EAAE,QAASC,GAAS,CAC1C,KAAK,qBAAqBD,EAAWC,EAAM,WAAW,CACxD,CAAC,EAED,OAAO,KAAK,UAAUD,CAAS,GAGjC,OAAO,KAAK,WAAWA,CAAS,CAClC,CAEA,WAAY,CACV,OAAO,KAAK,QAAQ,MACtB,CAEA,qBAAqBE,EAAsB,CACzC,MAAO,GAAG,KAAK,UAAA,CAAW,GAAGA,CAAI,EACnC,CAEQ,YAAYG,EAA8B,CAChD,MAAMG,EAAW,IAAI,iBAAkBC,GAAc,CACnDA,EAAU,QAASC,GAAa,CAE9B,CAAA,EAAG,QAAQ,KAAKA,EAAS,WAAaT,GAAe,CACnD,KAAK,uBAAuBA,CAAe,EAAE,QAASD,GAAc,CAClE,KAAK,qBAAqBA,EAAWC,EAAqB,UAAWS,CAAQ,CAC/E,CAAC,EAGD,UAAWV,KAAa,KAAK,WACvB,qBAAsBC,GACvBA,EAAqB,iBAA8B,IAAID,CAAS,GAAG,EAAE,QAASC,GAAsB,CACnG,KAAK,qBAAqBD,EAAWC,EAAM,UAAWS,CAAQ,CAChE,CAAC,CAGP,CAAC,EAED,CAAA,EAAG,QAAQ,KAAKA,EAAS,aAAeT,GAAkB,CACxD,KAAK,uBAAuBA,CAAI,EAAE,QAASD,GAAc,CACvD,KAAK,qBAAqBA,EAAWC,EAAqB,YAAaS,CAAQ,CACjF,CAAC,CACH,CAAC,EAEGA,EAAS,OAAS,cAAgBA,EAAS,UAAY,MACzD,KAAK,qBAAqBA,EAAS,cAAgBA,EAAS,OAAuB,UAAWA,CAAQ,CAE1G,CAAC,CACH,CAAC,EAED,OAAAF,EAAS,QAAQH,EAAS,CACxB,WAAY,GACZ,kBAAmB,GACnB,UAAW,GACX,cAAe,GACf,QAAS,EAAA,CACV,EAEM,IAAM,CACXG,EAAS,WAAA,CACX,CACF,CAEQ,gBAAgBH,EAA8B,CACpD,MAAMG,EAAW,IAAI,iBAAkBC,GAAc,CACnDA,EAAU,QAASC,GAAa,CAE1BA,EAAS,OAAS,cAAgB,CAAEA,EAAS,OAAmB,aAAaA,EAAS,aAAc,GACtG,KAAK,qBAAqBA,EAAS,cAAgBA,EAAS,OAAuB,YAAaA,CAAQ,EAG1G,KAAK,uBAAuBA,EAAS,MAAiB,EAAE,QAASV,GAAc,EAEzEU,EAAS,OAAS,cAAgBA,EAAS,OAAS,cACtD,KAAK,qBAAqBV,EAAWU,EAAS,OAAuB,UAAWA,CAAQ,CAE5F,CAAC,CACH,CAAC,CACH,CAAC,EAED,OAAAF,EAAS,QAAQH,EAAS,CACxB,WAAY,GACZ,UAAW,GACX,cAAe,GACf,kBAAmB,GACnB,sBAAuB,GACvB,gBAAiB,OAAO,KAAK,KAAK,UAAU,CAAA,CAC7C,EAEM,IAAM,CACXG,EAAS,WAAA,CACX,CACF,CAEA,OAAOG,EAA4B,CACjC,GAAI,KAAK,mBACP,MAAM,IAAI,MAAM,sCAAsC,EAGxD,KAAK,aAAeA,GAAU,SAAS,KAEvC,KAAK,mBAAqB,KAAK,YAAY,KAAK,YAAY,EAG5D,UAAWX,KAAa,KAAK,WAC3B,KAAK,sBAAsBA,CAAS,CAExC,CAEA,YAAa,CACP,KAAK,qBACP,KAAK,mBAAA,EACL,KAAK,mBAAqB,OAE9B,CAEA,aAAaA,EAAwC,CACnD,OAAO,KAAK,WAAWA,CAAS,CAClC,CAEQ,mBAAmBA,EAAmB,CAC5C,KAAM,CAACY,EAAa,GAAGC,CAAa,EAAIb,EAAU,MAAM,GAAG,EACrD,CAACE,EAAMY,CAAG,EAAIF,EAAY,MAAM,GAAG,EAEnCG,EAAqC,CAAA,EAC3C,OAAAF,EAAc,QAASG,GAAQ,CAC7BD,EAAUC,CAAG,EAAI,EACnB,CAAC,EAEM,CAAE,KAAAd,EAAM,IAAKY,GAAO,KAAM,UAAAC,CAAA,CACnC,CAEQ,qBACNf,EACAC,EACAgB,EACAP,EAAuC,OACvC,CACA,QAAQ,IAAIV,CAAS,EACrB,KAAM,CAAE,KAAAE,EAAM,IAAAY,EAAK,UAAAC,GAAc,KAAK,mBAAmBf,CAAS,EAClEA,EAAYE,EAEZ,MAAMC,EAAU,KAAK,aAAaH,CAAS,EAEvCG,GAAWc,KAAQd,IACjB,KAAK,QAAQc,CAAI,GAAG,QACtB,KAAK,MAAMA,CAAI,GAAG,SAASjB,EAAWC,CAAI,EAG5CE,EAAQc,CAAI,IAAIhB,EAAM,CACpB,UAAAD,EACA,KAAAC,EACA,MAAOA,EAAK,aAAaD,CAAS,EAClC,SAAUU,GAAU,SACpB,SAAAA,EACA,QAAAP,EACA,IAAAW,EACA,UAAAC,CAAA,CACD,EAEG,KAAK,QAAQE,CAAI,GAAG,OACtB,KAAK,MAAMA,CAAI,GAAG,QAAQjB,EAAWC,CAAI,EAG/C,CAEQ,uBAAuBA,EAAyB,CACtD,MAAMiB,EAAuB,CAAA,EAE7B,OAAKjB,EAAK,mBAIVA,EAAK,kBAAA,EAAoB,QAAS,GAAM,CAClC,EAAE,WAAW,KAAK,UAAA,CAAW,GAC/BiB,EAAW,KAAK,CAAC,CAErB,CAAC,EAEMA,GATE,CAAA,CAUX,CACF"}