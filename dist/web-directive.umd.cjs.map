{"version":3,"file":"web-directive.umd.cjs","sources":["../src/utilities/lifecycle.ts","../src/utilities/dom.ts","../src/utilities/text.ts","../src/utilities/timing.ts","../src/index.ts"],"sourcesContent":["import WebDirective from '../index';\n\nexport function useCurrentContext() {\n  if (!WebDirective.currentContext) {\n    throw new Error('No active context found.');\n  }\n\n  return WebDirective.currentContext;\n}\n","import { useCurrentContext } from './lifecycle';\n\nexport function setData(el: Element, name: string, value: any) {\n  // @ts-ignore\n  el[name] = value;\n}\n\nexport function getDate(el: Element, name: string): any {\n  // @ts-ignore\n  return el[name];\n}\n\nconst storageKey = `__webDirective.${createUid()}`;\n\nexport function singleton<E extends Element, T = any>(el: E, name: string): T | undefined;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory: false): T | undefined;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory: (el: E) => T): T;\nexport function singleton<E extends Element, T = any>(el: E, name: string, factory?: ((el: E) => T) | false): T | undefined {\n  const element = el as any;\n\n  element[storageKey] ??= {};\n\n  if (factory === false) {\n    const instance = element[storageKey][name];\n\n    delete element[storageKey][name];\n    return instance;\n  }\n\n  if (!element[storageKey][name] && factory) {\n    element[storageKey][name] = factory(el);\n  }\n\n  return element[storageKey][name];\n}\n\nfunction createUid() {\n  return Math.random().toString(36).substring(2, 10);\n}\n\nexport function useEventListener(el: Element, event: string, handler: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) {\n  const { el: baseEl, binding } = useCurrentContext();\n\n  el.addEventListener(event, handler, options);\n\n  const off = () => {\n    el.removeEventListener(event, handler, options);\n  };\n\n  baseEl.addEventListener('__wd:unmounted:' + binding.directive, (e) => {\n    off();\n  }, { once: true });\n\n  return off;\n}\n","export function toCamelCase(text: string): string {\n  return text.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n}\n\nexport function toKebabCase(text: string): string {\n  return text.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n","export function nextTick(): Promise<void> {\n  return Promise.resolve().then();\n}\n\n","import type { WebDirectiveBaseHook, WebDirectiveBinding, WebDirectiveHandler, WebDirectiveOptions } from './types';\nimport { toCamelCase, toKebabCase } from './utilities';\n\nexport { singleton, nextTick, useCurrentContext, useEventListener } from './utilities';\nexport type {\n  WebDirectiveBinding,\n  WebDirectiveHandler,\n  WebDirectiveOptions,\n} from './types';\n\nconst defaultOptions: Required<WebDirectiveOptions> = {\n  prefix: 'w-',\n  eventPrefix: 'wd:',\n  enableAttrParams: false,\n  enableChildrenUpdated: false,\n};\n\ninterface DirectiveInfo {\n  name: string;\n  handler: WebDirectiveHandler<any>;\n  elements: HTMLElement[];\n}\n\ninterface ElementInfo {\n  el: Element;\n  disconnect: () => void;\n  directives: string[];\n}\n\ntype HookTask = 'mounted' | 'unmounted' | 'updated' | 'childrenUpdated';\n\nclass WebDirective {\n  private directives: Record<string, DirectiveInfo> = {};\n\n  private attachedElements: WeakMap<Element, ElementInfo> = new WeakMap();\n\n  listenTarget: HTMLElement = document.body;\n\n  options: Required<WebDirectiveOptions>;\n\n  private disconnectCallback?: (() => void);\n\n  static currentContext: { el: Element, binding: WebDirectiveBinding } | null = null;\n\n  private hooks: {\n    mounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    unmounted: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    };\n    updated?: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    },\n    childrenUpdated?: {\n      before?: WebDirectiveBaseHook;\n      after?: WebDirectiveBaseHook;\n    }\n  } = {\n    mounted: {\n      before: (node, bindings) => {\n        const directive = bindings.directive;\n        const name = bindings.name;\n\n        let elementInfo = this.attachedElements.get(node);\n\n        if (!elementInfo) {\n          this.attachedElements.set(node, elementInfo = {\n            el: node,\n            disconnect: this.observeAttachedElement(node),\n            directives: [],\n          });\n        }\n\n        if (!elementInfo.directives.includes(directive)) {\n          elementInfo.directives.push(directive);\n        }\n      }\n    },\n    unmounted: {\n      after: (node, bindings) => {\n        const directive = bindings.directive;\n\n        const elementInfo = this.attachedElements.get(node);\n\n        if (elementInfo) {\n          const index = elementInfo.directives.indexOf(directive);\n\n          if (index > -1) {\n            elementInfo.directives.splice(index, 1);\n          }\n\n          if (elementInfo.directives.length === 0) {\n            elementInfo.disconnect();\n            this.attachedElements.delete(node);\n          }\n        }\n      }\n    }\n  };\n\n  constructor(options: WebDirectiveOptions = {}) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  listen(target?: HTMLElement): void {\n    if (this.disconnectCallback) {\n      throw new Error('This instance has already listening.');\n    }\n\n    this.listenTarget = target || document.body;\n\n    const disconnectRoot = this.observeRoot(this.listenTarget);\n\n    this.disconnectCallback = () => {\n      disconnectRoot();\n\n      for (const directive in this.directives) {\n        for (const element of this.directives[directive].elements) {\n          for (const directiveWithArgs of this.findDirectivesFromNode(element, directive)) {\n            this.runDirectiveIfExists(directiveWithArgs, element, 'unmounted');\n          }\n        }\n      }\n    };\n\n    // Mount registered directive before listen.\n    for (const directive in this.directives) {\n      this.findAndRunDirectivesOfSubtree(this.listenTarget, 'mounted', undefined, directive);\n    }\n  }\n\n  register<T extends Element = HTMLElement, M extends Record<string, boolean> = Record<string, boolean>>(\n    name: string,\n    handler: WebDirectiveHandler<T, M>\n  ) {\n    const directive = this.getDirectiveAttrName(name);\n    this.directives[directive] = {\n      name: directive,\n      handler: handler as WebDirectiveHandler<T, Record<string, boolean>>,\n      elements: []\n    };\n\n    // If listen not start, just register and back\n    if (!this.disconnectCallback) {\n      return;\n    }\n\n    // If listen already started, mount this directive\n    this.findAndRunDirectivesOfSubtree(this.listenTarget, 'mounted', undefined, directive);\n  }\n\n  // private mountDirectiveInitial(directive: string) {\n  //   this.findAndRunDirectivesOfSubtree(this.listenTarget, 'unmounted');\n  //\n  //   // if (this.options.enableAttrParams) {\n  //   //   for (const element of this.listenTarget.querySelectorAll<HTMLElement>('*')) {\n  //   //     this.findAndRunDirectivesFromNode(element, 'mounted', undefined, directive);\n  //   //\n  //   //     // const attributes = element.getAttributeNames();\n  //   //     //\n  //   //     // for (const attribute of attributes) {\n  //   //     //   if (attribute.startsWith(directive)) {\n  //   //     //     this.runDirectiveIfExists(attribute, element, 'mounted');\n  //   //     //   }\n  //   //     // }\n  //   //   }\n  //   //\n  //   //   return;\n  //   // }\n  //   //\n  //   // for (const element of this.listenTarget.querySelectorAll<HTMLElement>(`[${directive}]`)) {\n  //   //   this.runDirectiveIfExists(directive, element, 'mounted');\n  //   // }\n  // }\n\n  /**\n   * This method is to listen the root element for any changes.\n   * The listen event contains:\n   * - Child added/removed, and will scan all directives from added/removed nodes\n   * - Self Attributes changed\n   *\n   * This listener will run forever until disconnect() is called.\n   */\n  private observeRoot(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        // Added Nodes\n        for (const node of mutation.addedNodes) {\n          // Run self mounted\n          this.findAndRunDirectivesOfNode(node as HTMLElement, 'mounted', mutation);\n\n          // Run all subtree mounted\n          this.findAndRunDirectivesOfSubtree(node as HTMLElement, 'mounted', mutation);\n        }\n\n        // Handle if attributes remove from node\n        for (const node of mutation.removedNodes) {\n          // Run self unmounted\n          this.findAndRunDirectivesOfNode(node as HTMLElement, 'unmounted', mutation);\n\n          // Run all subtree unmounted\n          this.findAndRunDirectivesOfSubtree(node as HTMLElement, 'unmounted', mutation);\n\n          // this.findDirectivesFromNode(node).forEach((directiveWithArgs) => {\n          //   this.runDirectiveIfExists(directiveWithArgs, node as HTMLElement, 'unmounted', mutation);\n          // });\n        }\n\n        // Handle attributes value changed\n        const currentValue = (mutation.target as HTMLElement).getAttribute(mutation.attributeName!);\n\n        // If current value is NULL, it means the attribute is removed, so skip it here\n        // We will handle the removed case in the observeAttachedElement()\n        if (mutation.type === 'attributes' && currentValue != null) {\n          this.runDirectiveIfExists(\n            mutation.attributeName!,\n            mutation.target as HTMLElement,\n            mutation.oldValue == null ? 'mounted' : 'updated',\n            mutation\n          );\n        }\n      }\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      attributeOldValue: true,\n      childList: this.options.enableChildrenUpdated,\n      characterData: false,\n      subtree: true\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  /**\n   * This method is to listen an element which is attached at least 1 or more directives.\n   * The listen event contains:\n   * - Self attributes changed\n   * - Children changed (if enabled)\n   *\n   * And this listener will be removed when all directives are unmounted from this element.\n   */\n  private observeAttachedElement(element: Element): () => void {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        // Attributes updated\n        if (\n          mutation.type === 'attributes'\n          && mutation.attributeName\n          && mutation.target === element\n        ) {\n          if (!(mutation.target as Element).getAttribute(mutation.attributeName!)) {\n            // Remove\n            this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'unmounted', mutation);\n          } else {\n            // Attribute value changed\n            this.runDirectiveIfExists(mutation.attributeName!, mutation.target as HTMLElement, 'updated', mutation);\n          }\n        }\n\n        // Children changed. Let's run all attributes\n        if (this.options.enableChildrenUpdated && mutation.type === 'childList') {\n          for (const directiveWithArgs of this.findDirectivesFromNode(element)) {\n            this.runDirectiveIfExists(directiveWithArgs, element as HTMLElement, 'childrenUpdated', mutation);\n          }\n        }\n      }\n    });\n\n    observer.observe(element, {\n      attributes: true,\n      childList: this.options.enableChildrenUpdated,\n      subtree: this.options.enableChildrenUpdated,\n      characterData: true,\n      attributeOldValue: true,\n      characterDataOldValue: true,\n      // attributeFilter: Object.keys(this.directives)\n    });\n\n    return () => {\n      observer.disconnect();\n    };\n  }\n\n  remove(name: string) {\n    const directive = this.getDirectiveAttrName(name);\n\n    if (this.directives[directive]) {\n      for (const element of this.directives[directive].elements) {\n        for (const directiveWithArgs of this.findDirectivesFromNode(element, directive)) {\n          this.runDirectiveIfExists(directiveWithArgs, element, 'unmounted');\n        }\n      }\n\n      delete this.directives[directive];\n    }\n  }\n\n  getPrefix() {\n    return this.options.prefix;\n  }\n\n  getDirectiveAttrName(name: string): string {\n    return `${this.getPrefix()}${name}`;\n  }\n\n  disconnect() {\n    if (this.disconnectCallback) {\n      this.disconnectCallback();\n      this.disconnectCallback = undefined;\n    }\n  }\n\n  getDirectiveInfo(directive: string): DirectiveInfo | undefined {\n    return this.directives[directive];\n  }\n\n  private splitDirectiveArgs(directive: string) {\n    const [nameWithArg, ...modifierParts] = directive.split('.');\n    const [name, arg] = nameWithArg.split(':');\n\n    const modifiers: Record<string, boolean> = {};\n    modifierParts.forEach((mod) => {\n      modifiers[toCamelCase(mod)] = true;\n    });\n\n    return { name, arg: arg || null, modifiers };\n  }\n\n  private runDirectiveIfExists(\n    directive: string,\n    el: HTMLElement,\n    task: HookTask,\n    mutation: MutationRecord | undefined = undefined\n  ) {\n    const { name, arg, modifiers } = this.splitDirectiveArgs(directive);\n\n    const info = this.getDirectiveInfo(name);\n\n    if (!info) {\n      return;\n    }\n\n    if (task === 'mounted') {\n      // Add element to directive map\n      info.elements.push(el);\n    } else if (task === 'unmounted') {\n      // Remove element from directive map\n      const index = info.elements.indexOf(el);\n\n      if (index > -1) {\n        info.elements.splice(index, 1);\n      }\n    }\n\n    const handler = info.handler;\n\n    const binding: WebDirectiveBinding = {\n      directive,\n      name,\n      node: el,\n      value: el.getAttribute(directive),\n      oldValue: mutation?.oldValue,\n      mutation,\n      handler,\n      arg,\n      modifiers,\n      instance: this,\n    };\n\n    WebDirective.currentContext = { el, binding };\n\n    if (this.hooks?.[task]?.before) {\n      this.hooks[task]?.before?.(el, binding);\n    }\n\n    if (task in handler) {\n      handler[task]?.(el, binding);\n    }\n\n    if (this.hooks?.[task]?.after) {\n      this.hooks[task]?.after?.(el, binding);\n    }\n\n    const eventPrefix = this.options.eventPrefix;\n\n    el.dispatchEvent(new CustomEvent(eventPrefix + toKebabCase(task), { detail: { el, binding }}));\n    el.dispatchEvent(new CustomEvent(`__wd:${task}:${binding.directive}`, { detail: { el, binding }}));\n\n    WebDirective.currentContext = null;\n  }\n\n  private findAndRunDirectivesOfNode(\n    node: HTMLElement,\n    task: HookTask,\n    mutation?: MutationRecord,\n    directive?: string,\n  ) {\n    for (const directiveWithArgs of this.findDirectivesFromNode(node, directive)) {\n      this.runDirectiveIfExists(directiveWithArgs, node, task, mutation);\n    }\n  }\n\n  private findAndRunDirectivesOfSubtree(node: Element, task: HookTask, mutation?: MutationRecord, directive?: string) {\n    if (!('querySelectorAll' in node)) {\n      return;\n    }\n\n    if (this.options.enableAttrParams) {\n      for (const childNode of node.querySelectorAll<HTMLElement>('*')) {\n        this.findAndRunDirectivesOfNode(childNode, task, mutation, directive);\n      }\n    } else {\n      const directives = directive ? [directive] : Object.keys(this.directives);\n\n      for (const directive of directives) {\n        for (const element of node.querySelectorAll<HTMLElement>(`[${directive}]`)) {\n          this.runDirectiveIfExists(directive, element, task);\n        }\n      }\n    }\n  }\n\n  private findDirectivesFromNode(node: Element, directive?: string): string[] {\n    const directives: string[] = [];\n\n    if (!node.getAttributeNames) {\n      return [];\n    }\n\n    node.getAttributeNames().forEach((e) => {\n      if (e.startsWith(this.getPrefix())) {\n        if (!directive) {\n          directives.push(e);\n        } else if (e.startsWith(directive)) {\n          directives.push(e);\n        }\n      }\n    });\n\n    return directives;\n  }\n}\n\nexport default WebDirective;\n"],"names":["useCurrentContext","WebDirective","storageKey","createUid","singleton","el","name","factory","element","instance","useEventListener","event","handler","options","baseEl","binding","off","e","toCamelCase","text","g","toKebabCase","nextTick","defaultOptions","_WebDirective","node","bindings","directive","elementInfo","index","target","disconnectRoot","directiveWithArgs","observer","mutations","mutation","currentValue","nameWithArg","modifierParts","arg","modifiers","mod","task","info","eventPrefix","childNode","directives"],"mappings":"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"}